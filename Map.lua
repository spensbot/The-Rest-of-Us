Map = Class{}

local mapImagePath = 'images/map_1.png'
local gridScale = 300 --number of pixels that corresponds to each pixel in the map image
local miniMapWidth = 200
local markerColor = {0,1,0,1}
local miniBackgroundColor = {.1,.1,.1,.7}
local markerInnerRadius = 2
local markerOutterRadius = 6

--Data tables {x, y, ...}
local barriersData = {} --Generated from black pixels in map image
local storyPointsData = {} --Generated by hand below
--saveState.searchablesData = {} --Generated from blue pixels

--Object tables (populated with objects (based on data) when within range)
local storyPoints = {}
--global.barriers = {}
--global.searchables = {}
local terrainObjects = {} --has no data table

local storyPointsData = {
	{1900, 9000, "Welcome, Maurice, to the best game you've ever played."},
	{1200, 9300, "My name is Glob. I will guide you through this world. One day, we will all live in peace as a collective cybernet in a collective google search."}
}

function Map:init()
	self.mapImage = love.graphics.newImage(mapImagePath)
	self.mapImageData = love.image.newImageData(mapImagePath)
	self.mapPixelData = {}
	self.mapImageWidth = self.mapImage:getWidth()
	self.mapImageHeight = self.mapImage:getHeight()
	self.miniMapHeight = miniMapWidth * self.mapImageHeight/self.mapImageWidth
	self.miniMapScale = miniMapWidth/self.mapImageWidth
	self.miniMapX = WINDOW_WIDTH - miniMapWidth - PADDING*2
	self.miniMapY = PADDING*2
	self.markerX = 0
	self.markerY = 0
	self:readMapData()
end

function Map:update(dt)
	self.markerX = self.miniMapX + saveState.mapX/gridScale*self.miniMapScale
	self.markerY = self.miniMapY + saveState.mapY/gridScale*self.miniMapScale
	self:updateTerrainObjects(dt)
	self:updateBarriers(dt)
	self:updateStoryPoints(dt)
	self:updateSearchables(dt)
	self:updateDropPackages(dt)
end

function Map:render()
	for i, terrainObject in pairs(terrainObjects)do
		terrainObject:render()
	end
	for i, barrier in pairs(global.barriers) do
		barrier:render()
	end
	for i, searchable in pairs(global.searchables) do
		searchable:render()
	end
	for i, storyPoint in pairs(storyPoints) do
		storyPoint:render()
	end
	for i, dropPackage in pairs(global.dropPackages) do
		dropPackage:render()
	end
	self:renderMiniMap()
end


------------------------------------ HELPER FUNCTIONS -------------------------------------

function Map:readMapData()
--Read image data to a matrix
	--iterate 1 column at a time
	for x = 1, self.mapImageData:getWidth() do
		local column = {} 
		--iterate through each pixel in the column
		for y = 1, self.mapImageData:getHeight() do
			local pixel = {}
			pixel[1],pixel[2],pixel[3],pixel[4] = self.mapImageData:getPixel(x-1, y-1)
			column[y] = pixel
		end
		self.mapPixelData[x] = column
	end

	--Iterate through the matrix, and look for certain pixel types to generate the map.
	--Iterate through 1 column at a time
	for x = 1, self.mapImageData:getWidth() do
		--Iterate throught each pixel in the column
		for y = 1, self.mapImageData:getHeight() do
			
			if self.mapPixelData[x][y][4] == 1 then --This pixel is fully opaque (no Alpha). Something should be placed in this space.
				local objectMapX, objectMapY = self:getMapCoordinatesFromPixel(x,y)
				
				--look for the black pixels. Add a barrier object for each one.
				if self.mapPixelData[x][y][1] == 0 and self.mapPixelData[x][y][2] == 0 and self.mapPixelData[x][y][3] == 0 then
					table.insert(barriersData, {['mapX'] = objectMapX, ['mapY'] = objectMapY, ['type'] = 'barrier'})

				--Pixels with only red will spawn enemies. A higher red value should spawn a stronger enemy.
				elseif self.mapPixelData[x][y][1] > 0 and self.mapPixelData[x][y][2] == 0 and self.mapPixelData[x][y][3] == 0 then
					spawnEnemy(objectMapX, objectMapY, 'drone', 10, 'Rusty Knife')

				--Pixels with only blue will spawn searchables.
				elseif self.mapPixelData[x][y][1] == 0 and self.mapPixelData[x][y][2] == 0 and self.mapPixelData[x][y][3] > 0 then
					local inventoryTable = {['Quartz'] = 10, ['Health Kit'] = 1}
					table.insert(saveState.searchablesData, {['mapX'] = objectMapX, ['mapY'] = objectMapY, ['type'] = 'chest', ['inventory'] = inventoryTable})
				end
			end
		end
	end
end

function Map:getMapCoordinatesFromPixel(x,y)
	local mapX, mapY = 0, 0
	mapX = x * gridScale
	mapY = y * gridScale
	return mapX, mapY
end

function Map:updateTerrainObjects(dt)
	local maxTerrainObjects = 100
	local minTerrainSpacing = 350
	local spawnDistance = WINDOW_WIDTH*1.5
	--First, remove objects that are too far from the player
	for i, terrainObject in pairs(terrainObjects) do
		if math.abs((terrainObject.mapX - saveState.mapX)) > spawnDistance
		or math.abs((terrainObject.mapY - saveState.mapY)) > spawnDistance then 
			table.remove(terrainObjects, i)
		end
	end

	--Next, add objects as necessary to reach maxTerrainObjects
	local attempts = 0
	while #terrainObjects < maxTerrainObjects do
		local relativeX = math.random(-spawnDistance, spawnDistance) 
		local relativeY = math.random(-spawnDistance, spawnDistance) 
		local newMapX = saveState.mapX + relativeX
		local newMapY = saveState.mapY + relativeY

		--Ensure that the new object will not appear in the screen.
		if math.abs(newMapX - saveState.mapX) > WINDOW_WIDTH*2/3
		or math.abs(newMapY - saveState.mapY) > WINDOW_HEIGHT*2/3 then
			--Ensure that the new terrain object will not be too close to existing objects.
			local hasSpace = true
			for i, terrainObject in pairs(terrainObjects) do 
				if math.abs((terrainObject.mapX - newMapX)) < minTerrainSpacing
				and math.abs((terrainObject.mapY - newMapY)) < minTerrainSpacing then
					hasSpace = false
				end
			end
			if hasSpace then
				table.insert(terrainObjects, TerrainObject(newMapX, newMapY, 'terrain'))
				attempts = 0
			end
		end
		if attempts > maxTerrainObjects then 
			break
		end
		attempts = attempts + 1
	end

	--Update the terrain objects
	for i, terrainObject in pairs(terrainObjects)do
		terrainObject:update(dt)
	end
end

function Map:updateBarriers(dt) 
	local spawnDistance = WINDOW_WIDTH
	--Remove objects that are too far from the player
	for i, barrier in pairs(global.barriers) do
		if math.abs((barrier.mapX - saveState.mapX)) > spawnDistance
		or math.abs((barrier.mapY - saveState.mapY)) > spawnDistance then 
			global.barriers[i] = nil
		end
	end

	--Add objects for any object data that is close to the player
	for i, barrierData in pairs(barriersData) do

		--Check if an Obstacle instance exists for that data point.
		if global.barriers[i] == nil then

			--If the obstacle is within spawn distance from the player, create an Obstacle instance.
			if math.abs((barrierData.mapX - saveState.mapX)) < spawnDistance
			and math.abs((barrierData.mapY - saveState.mapY)) < spawnDistance then 
				global.barriers[i] = MapObject(barrierData.mapX, barrierData.mapY, barrierData.type, gridScale, true)
			end
		end
	end

	for i, barrier in pairs(global.barriers) do
		barrier:update(dt)
	end
end

function Map:updateSearchables(dt) 
	local spawnDistance = WINDOW_WIDTH
	--Remove objects that are too far from the player
	for i, searchable in pairs(global.searchables) do
		if math.abs((searchable.mapX - saveState.mapX)) > spawnDistance
		or math.abs((searchable.mapY - saveState.mapY)) > spawnDistance then 
			global.searchables[i] = nil
		end
	end

	--Add objects for any object data that is close to the player
	for i, searchableData in pairs(saveState.searchablesData) do

		--Check if an Obstacle instance exists for that data point.
		if global.searchables[i] == nil then

			--If the obstacle is within spawn distance from the player, create an Obstacle instance.
			if math.abs((searchableData.mapX - saveState.mapX)) < spawnDistance
			and math.abs((searchableData.mapY - saveState.mapY)) < spawnDistance then 
				global.searchables[i] = MapObject(searchableData.mapX, searchableData.mapY, searchableData.type, 150, true, searchableData.inventory)
			end
		end
	end

	for i, searchable in pairs(global.searchables) do
		searchable:update(dt)
	end
end

function Map:updateStoryPoints(dt) 
	local spawnDistance = WINDOW_WIDTH
	--Remove objects that are too far from the player
	for i, storyPoint in pairs(storyPoints) do
		if math.abs((storyPoint.mapX - saveState.mapX)) > spawnDistance
		or math.abs((storyPoint.mapY - saveState.mapY)) > spawnDistance then 
			storyPoints[i] = nil
		end
	end

	--Add objects for any object data that is close to the player
	for i, storyPointData in pairs(storyPointsData) do

		--Check if an Obstacle instance exists for that data point.
		if storyPoints[i] == nil then

			--If the obstacle is within spawn distance from the player, create an Obstacle instance.
			if math.abs((storyPointData[1] - saveState.mapX)) < spawnDistance
			and math.abs((storyPointData[2] - saveState.mapY)) < spawnDistance then 
				storyPoints[i] = StoryPoint(storyPointData[1], storyPointData[2], storyPointData[3])
			end
		end
	end

	for i, storyPoint in pairs(storyPoints) do
		storyPoint:update(dt)
	end
end

function Map:updateDropPackages(dt)
	local dropPackageSpawnDistance = WINDOW_WIDTH * 5
	for i, dropPackage in pairs(global.dropPackages) do
		if getDistance(saveState.mapX, saveState.mapY, dropPackage.mapX, dropPackage.mapY) > dropPackageSpawnDistance then 
			table.remove(global.dropPackages, i)
		end
	end

	for i, dropPackage in pairs(global.dropPackages) do
		dropPackage:update(dt)
	end
end

function Map:renderMiniMap()
	love.graphics.setColor(miniBackgroundColor)
	love.graphics.rectangle('fill', self.miniMapX - PADDING, PADDING, miniMapWidth + PADDING*2, self.miniMapHeight + PADDING*2, 10)
	love.graphics.setColor(WHITE)
	love.graphics.draw(self.mapImage, self.miniMapX, self.miniMapY, 0, self.miniMapScale, self.miniMapScale)
	love.graphics.setLineWidth(2)
	love.graphics.setColor(markerColor)
	love.graphics.circle('line', self.markerX, self.markerY, markerOutterRadius)
	love.graphics.circle('fill', self.markerX, self.markerY, markerInnerRadius)
end